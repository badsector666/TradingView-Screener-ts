<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>TV Scanner ‚Ä¢ GitHub Metainfo + Orama + Virtualized</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<!-- Orama (CDN ESM) -->
<script type="module" id="orama-loader">
  import { create, insert, search } from "https://cdn.jsdelivr.net/npm/@orama/orama@3.1.6/dist/index.js";
  window.Orama = { create, insert, search };
</script>
<style>
  :root { --bg:#0f1115; --fg:#e6e6e6; --muted:#9aa4b2; --line:#1f2430; --accent:#60a5fa; }
  *{ box-sizing:border-box }
  body{ margin:0; font:14px/1.45 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto; color:var(--fg); background:var(--bg) }
  header{ display:grid; gap:16px; grid-template-columns:1fr 1fr; padding:20px 16px; border-bottom:1px solid var(--line); background: linear-gradient(135deg, #0f1115 0%, #141821 100%); }
  .header-section{ display:flex; flex-direction:column; gap:12px; padding:16px; background: #141821; border:1px solid #2a3142; border-radius:12px; }
  .section-title{ font-size:16px; font-weight:700; color:var(--accent); margin-bottom:8px; }
  .controls-row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .control-group{ display:flex; flex-direction:column; gap:6px; min-width:120px; }
  header>div{ display:flex; flex-direction:column; gap:6px }
  label{ font-size:12px; color:var(--muted) }
  input,button,select{ background:#141821; color:var(--fg); border:1px solid #2a3142; border-radius:8px; padding:8px 10px }
  button{ cursor:pointer; font-weight:600 }
  .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
  .badge{ background:#172554; border:1px solid #1e3a8a; color:#93c5fd; padding:2px 6px; border-radius:6px; font-size:12px }

  /* Dropdowns */
  .dd{ position:relative }
  .dd>button{ width:100%; text-align:left }
  .panel{ position:absolute; top:100%; left:0; right:0; background:#0f121a; border:1px solid #2a3142; border-radius:10px; padding:8px; margin-top:6px; z-index:10; display:none }
  .panel.open{ display:block }
  .panel .search{ width:100%; margin-bottom:8px }
  .list{ max-height:260px; overflow:auto; border:1px solid #1b2130; border-radius:8px }
  .item{ display:flex; align-items:center; gap:8px; padding:6px 8px; border-bottom:1px solid #151b27 }
  .item:last-child{ border-bottom:none }

  /* Table / virtualization */
  #status{ padding:8px 16px; border-bottom:1px solid var(--line); color:var(--muted) }
  #thead-container{ position:sticky; top:0; z-index:2; background:var(--bg); }
  #thead{ border-bottom:1px solid var(--line) }
  #thead .th{ font-weight:700; padding:10px; border-right:1px solid var(--line); white-space:nowrap }
  #filter-row { border-bottom:1px solid var(--line); }
  #filter-row .cell { padding: 4px; }
  #filter-row input { width: 100%; background: #0f1115; border: 1px solid #2a3142; color: var(--fg); padding: 6px 8px; border-radius: 6px; }
  #viewport{ height:calc(100vh - 300px); overflow:auto; position:relative }
  #spacer{ position:relative; width:100% }
  #rows{ position:absolute; top:0; left:0; right:0 }
  .row-item{ display:grid; grid-template-columns:320px repeat(var(--cols,1),minmax(120px,1fr)); border-bottom:1px solid #1a1f2b; min-height:32px; align-items:center }
  .cell{ padding:6px 10px; border-right:1px solid #1a1f2b; overflow:hidden; text-overflow:ellipsis; white-space:nowrap }
  .symbol{ color:#7dd3fc; font-weight:600 }
  .hint{ color:#9aa4b2; font-size:12px }
</style>
</head>
<body>
<header>
  <div class="dd" id="ddMarkets">
    <label>Markets (from GitHub metainfo)</label>
    <button type="button" id="btnMarkets">Choose markets‚Ä¶</button>
    <div class="panel" id="panelMarkets">
      <input class="search" id="searchMarkets" placeholder="Search markets‚Ä¶" />
      <div class="row">
        <span class="badge" id="marketCount">0 selected</span>
        <button id="loadMarkets">Load from GitHub</button>
        <button id="refreshMarkets" title="Clear cache">Refresh</button>
        <button id="exportCache">Export JSON</button>
        <input type="file" id="importCache" style="display:none" />
        <button id="importBtn">Import JSON</button>
      </div>
      <div class="list" id="listMarkets"></div>
      <div class="hint" style="padding:6px 4px">Reads <code>docs/data/metainfo/*.json</code> in the repo.</div>
    </div>
  </div>

  <div class="dd" id="ddColumns">
    <label>Columns (auto-inferred from metainfo)</label>
    <button type="button" id="btnColumns">Choose columns‚Ä¶</button>
    <div class="panel" id="panelColumns">
      <input class="search" id="searchColumns" placeholder="Search columns‚Ä¶" />
      <div class="row">
        <span class="badge" id="colCount">0 selected</span>
        <button id="loadColumns">Load Columns</button>
        <button id="refreshColumns" title="Clear selected markets‚Äô columns">Refresh</button>
        <select id="tfSuffix">
          <option value="">(no timeframe suffix)</option>
          <option value="|1">|1 (1m)</option>
          <option value="|3">|3 (3m)</option>
          <option value="|5">|5 (5m)</option>
          <option value="|15">|15 (15m)</option>
          <option value="|60">|60 (1h)</option>
          <option value="|240">|240 (4h)</option>
          <option value="|1D">|1D</option>
          <option value="|1W">|1W</option>
          <option value="|1M">|1M</option>
        </select>
        <button id="applySuffix">Apply to selected</button>
      </div>
      <div class="list" id="listColumns"></div>
      <div class="hint" style="padding:6px 4px">Metainfo fields: <code>{ n, t, r }</code>. We use <code>n</code> as column key; optional timeframe suffix adds <code>|TF</code>.</div>
    </div>
  </div>

  <div>
    <label>Sort By</label>
    <select id="sortBy"></select>
    <label style="margin-top:6px">Sort Order</label>
    <select id="sortOrder"><option>asc</option><option>desc</option></select>
  </div>

  <div>
    <label>Batch size</label>
    <input id="batch" type="number" min="100" max="5000" step="100" value="5000" />
    <div class="row"><span class="badge" id="countBadge">Rows: 0</span>
      <span class="badge" id="loadedBadge">Loaded: 0</span></div>
  </div>
</header>

<div class="controls-row" style="padding: 10px 16px; border-bottom: 1px solid var(--line); justify-content: center; gap: 16px;">
    <button id="fetch" style="background: var(--accent); border-color: var(--accent); font-weight: 700; padding: 12px 24px;">üöÄ Fetch & Render</button>
    <button id="stop" style="background: #dc2626; border-color: #dc2626; padding: 12px 24px;">‚èπÔ∏è Stop</button>
    <button id="exportResults" style="background: #3b82f6; border-color: #3b82f6; padding: 12px 24px;">üì§ Export Results</button>
</div>

<div id="status">Idle.</div>

<!-- Search bar for table data -->
<div id="table-search-container" style="padding: 12px 16px; border-bottom: 1px solid var(--line); background: #141821;">
  <div style="display: flex; gap: 12px; align-items: center;">
    <label style="font-size: 12px; color: var(--muted); white-space: nowrap;">Global Search:</label>
    <input id="tableSearch" placeholder="Search all columns..." style="flex: 1; background: #0f1115; border: 1px solid #2a3142; border-radius: 8px; padding: 8px 12px; color: var(--fg);" />
    <button id="clearSearch" style="padding: 8px 12px; background: #1f2937; border: 1px solid #374151; border-radius: 6px; color: var(--muted); cursor: pointer;">Clear</button>
    <span id="searchResults" class="badge" style="background: #1e3a8a; color: #93c5fd;">Showing all</span>
  </div>
</div>

<!-- Table header -->
<div id="thead-container">
  <div id="thead" class="row-item" style="--cols: 0">
    <div class="th cell">s (symbol)</div>
  </div>
  <div id="filter-row" class="row-item" style="--cols: 0">
    <div class="cell"><input class="col-filter" placeholder="Filter..." data-col-idx="-1" /></div>
  </div>
</div>

<!-- Virtualized viewport -->
<div id="viewport"><div id="spacer" style="height:0px;"><div id="rows"></div></div></div>

<script type="module">
  const $ = id => document.getElementById(id);
  const state = {
    stop:false, rows:[], filteredRows:[], rowHeight:32, buffer:8, total:0, loaded:0,
    selectedMarkets:new Set(), selectedColumns:new Set(),
    cacheKey:"tv_meta_cache_v1",
    cache:{ markets:[], columnsByMarket:{}, discoveredAt:null },
    searchQuery: "",
    columnFilters: {} // { colIndex: "filter string" }
  };

  const ui = {
    marketItems: [],   // [{id,label}]
    columnItems: []    // [{id,label}]
  };

  const debounce = (fn, ms = 200) => {
    let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
  };

  function filterItems(items, q) {
    if (!q) return items;
    const term = q.trim().toLowerCase();
    return items.filter(it =>
      it.label.toLowerCase().includes(term) || it.id.toLowerCase().includes(term)
    );
  }

  // Map GitHub metainfo files -> ‚Äúmarket‚Äù ids to use in TV scanner
  const META = {
    bond: "bond.json",
    bonds: "bonds.json",
    cfd: "cfd.json",
    coin: "coin.json",
    crypto: "crypto.json",
    economics2: "economics2.json",
    forex: "forex.json",
    futures: "futures.json",
    ireland: "ireland.json",
    options: "options.json",
    stocks: "stocks.json"
  };
  const GH_BASE = "https://raw.githubusercontent.com/shner-elmo/TradingView-Screener/docs/data/metainfo/";

  // Dropdown open/close
  const ddHook = (btn, panel) => {
    btn.addEventListener("click", () => panel.classList.toggle("open"));
    document.addEventListener("click", (e) => { if(!panel.contains(e.target) && e.target!==btn) panel.classList.remove("open"); });
  };
  ddHook($("btnMarkets"), $("panelMarkets"));
  ddHook($("btnColumns"), $("panelColumns"));

  // Cache
  function saveCache(){ state.cache.discoveredAt = new Date().toISOString(); localStorage.setItem(state.cacheKey, JSON.stringify(state.cache)); }
  function loadCache(){ try{ const raw=localStorage.getItem(state.cacheKey); if(raw) state.cache = JSON.parse(raw); }catch{} }

  // Orama
  let dbMarkets, dbColumns;
  async function buildIndex(items){
    const db = await Orama.create({ schema:{ id:"string", label:"string" } });
    for(const it of items) await Orama.insert(db, it);
    return db;
  }

  function setStatus(s){ $("status").textContent=s; }
  function updateBadges(){
    $("marketCount").textContent = `${state.selectedMarkets.size} selected`;
    $("colCount").textContent = `${state.selectedColumns.size} selected`;
    $("countBadge").textContent = `Rows: ${state.total}`;
    $("loadedBadge").textContent = `Loaded: ${state.loaded}`;
    updateSearchResults();
  }

  function updateSearchResults(){
    const showing = state.filteredRows.length;
    const total = state.rows.length;
    const hasGlobalSearch = state.searchQuery.trim();
    const hasColFilters = Object.values(state.columnFilters).some(f => f.trim());

    if(hasGlobalSearch || hasColFilters) {
      $("searchResults").textContent = `Showing ${showing} of ${total}`;
    } else {
      $("searchResults").textContent = `Showing all`;
    }
  }

  function filterRows(){
    const globalQuery = state.searchQuery.trim().toLowerCase();
    const colFilters = Object.entries(state.columnFilters)
      .map(([idx, q]) => [parseInt(idx, 10), q.trim().toLowerCase()])
      .filter(([, q]) => q);

    if(!globalQuery && colFilters.length === 0) {
      state.filteredRows = state.rows;
    } else {
      state.filteredRows = state.rows.filter(row => {
        // Column filters
        for (const [idx, q] of colFilters) {
          const cellValue = idx === -1 ? row.s : (row.d && row.d[idx]);
          if (!cellValue || !cellValue.toString().toLowerCase().includes(q)) {
            return false;
          }
        }

        // Global search (if all column filters passed)
        if (globalQuery) {
          if(row.s && row.s.toLowerCase().includes(globalQuery)) return true;
          if(Array.isArray(row.d)) {
            return row.d.some(cell => 
              cell && cell.toString().toLowerCase().includes(globalQuery)
            );
          }
          return false; // No match in global search
        }
        
        return true; // All column filters passed, no global search
      });
    }
    setContainerHeight();
    renderRows();
    updateSearchResults();
  }

  function renderCheckList(container, items, selectedSet, isColumns = false){
    const frag = document.createDocumentFragment();
    for(const it of items){
      const row = document.createElement("label");
      row.className = "item";
      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.checked = selectedSet.has(it.id);
      cb.addEventListener("change", () => {
        if (cb.checked) selectedSet.add(it.id);
        else selectedSet.delete(it.id);
        updateBadges();
        if (isColumns) {
          renderHeader();
        } else {
          // When markets change, we need to reload columns
          hydrateColumnsUI();
        }
      });
      const span = document.createElement("span");
      span.textContent = it.label;
      row.append(cb, span);
      frag.appendChild(row);
    }
    container.replaceChildren(frag);
  }

  async function hydrateMarketsUI(){
    ui.marketItems = (state.cache.markets || []).map(m => ({ id: m, label: m }));
    renderCheckList($("listMarkets"), ui.marketItems, state.selectedMarkets, false);
    updateBadges();
  }

  async function hydrateColumnsUI(){
    const uni = new Set();
    for (const m of state.selectedMarkets) {
      (state.cache.columnsByMarket[m] || []).forEach(c => uni.add(c));
    }
    ui.columnItems = [...uni].sort((a,b)=>a.localeCompare(b)).map(c => ({ id: c, label: c }));
    
    // Filter out columns that are no longer valid
    const validCols = new Set(ui.columnItems.map(i => i.id));
    state.selectedColumns = new Set([...state.selectedColumns].filter(c => validCols.has(c)));

    renderCheckList($("listColumns"), ui.columnItems, state.selectedColumns, true);
    updateBadges();
    renderHeader(); // Update header when columns change
  }

  // Load markets: just the keys from META that actually fetch successfully
  async function loadMarketsFromGitHub(){
    setStatus("Loading markets from GitHub metainfo‚Ä¶");
    const found = [];
    for(const m of Object.keys(META)){
      try{
        const url = GH_BASE + META[m];
        const res = await fetch(url);
        if(res.ok){ found.push(m); }
      }catch{}
      await new Promise(r=>setTimeout(r,0));
    }
    state.cache.markets = found.sort();
    saveCache();
    await hydrateMarketsUI();
    setStatus(`Markets ready: ${state.cache.markets.join(", ")}`);
  }

  // Load columns for selected markets by reading {n,t,r} array and collecting n
  async function loadColumnsForSelected(){
    if(state.selectedMarkets.size===0){ setStatus("Select at least one market first."); return; }
    setStatus("Loading columns from GitHub metainfo‚Ä¶");
    for(const m of state.selectedMarkets){
      if (state.cache.columnsByMarket[m]) continue; // Skip if already loaded
      try{
        const url = GH_BASE + META[m];
        const arr = await fetch(url).then(r=>r.json());
        // Expect array of objects with "n" (name), "t" (type), "r" (range or null)
        const names = [];
        for(const it of arr){
          if(it && typeof it.n === "string" && it.n.trim()) names.push(it.n.trim());
        }
        // dedupe and sort
        state.cache.columnsByMarket[m] = [...new Set(names)].sort();
      }catch(e){
        console.warn("Failed loading columns for", m, e);
      }
      await new Promise(r=>setTimeout(r,0));
    }
    saveCache();
    await hydrateColumnsUI();
    setStatus("Columns loaded for selected markets.");
  }

  // Search handlers
  $("searchMarkets").addEventListener("input", debounce(e => {
    const q = e.target.value;
    const filtered = filterItems(ui.marketItems, q);
    renderCheckList($("listMarkets"), filtered, state.selectedMarkets, false);
  }));
  $("searchColumns").addEventListener("input", debounce(e => {
    const q = e.target.value;
    const filtered = filterItems(ui.columnItems, q);
    renderCheckList($("listColumns"), filtered, state.selectedColumns, true);
  }));

  // Apply timeframe suffix to selected columns (e.g., close -> close|60)
  $("applySuffix").addEventListener("click", ()=>{
    const suffix = $("tfSuffix").value || "";
    if(!suffix) return;
    const augmented = new Set();
    for(const c of state.selectedColumns) augmented.add(c.split('|')[0] + suffix);
    state.selectedColumns = augmented;
    hydrateColumnsUI();
  });

  // Virtualized table
  const $viewport=$("viewport"), $spacer=$("spacer"), $rows=$("rows"), $thead=$("thead"), $filterRow=$("filter-row");
  
  function renderHeader(){
    const cols = [...state.selectedColumns];
    const sortBy = $("sortBy");
    const currentSort = sortBy.value;
    
    $thead.innerHTML = '<div class="th cell">s (symbol)</div>';
    $filterRow.innerHTML = '<div class="cell"><input class="col-filter" placeholder="Filter..." data-col-idx="-1" /></div>';
    
    const gridTemplateColumns = `320px repeat(${cols.length}, minmax(120px, 1fr))`;
    $thead.style.gridTemplateColumns = gridTemplateColumns;
    $filterRow.style.gridTemplateColumns = gridTemplateColumns;
    document.documentElement.style.setProperty("--cols", cols.length);

    sortBy.innerHTML = '<option value="name">name</option>';
    for(const c of cols){
      const opt = document.createElement("option");
      opt.value = c;
      opt.textContent = c;
      sortBy.appendChild(opt);
    }
    if (currentSort && (cols.includes(currentSort) || currentSort === 'name')) {
      sortBy.value = currentSort;
    } else {
      sortBy.value = "name";
    }

    cols.forEach((c, i) => {
      const th = document.createElement("div");
      th.className="th cell";
      th.textContent=c;
      $thead.appendChild(th);

      const filterCell = document.createElement("div");
      filterCell.className = "cell";
      const input = document.createElement("input");
      input.className = "col-filter";
      input.placeholder = `Filter...`;
      input.dataset.colIdx = i;
      filterCell.appendChild(input);
      $filterRow.appendChild(filterCell);
    });
  }
  
  function setContainerHeight(){ $spacer.style.height = (state.filteredRows.length*state.rowHeight)+"px"; }
  function visibleRange(){
    const scrollTop=$viewport.scrollTop, vh=$viewport.clientHeight;
    const start=Math.max(0,Math.floor(scrollTop/state.rowHeight)-state.buffer);
    const end=Math.min(state.filteredRows.length,Math.ceil((scrollTop+vh)/state.rowHeight)+state.buffer);
    return {start,end,offsetTop:start*state.rowHeight};
  }
  function renderRows(){
      const { start, end, offsetTop } = visibleRange();
      $rows.style.transform = `translateY(${offsetTop}px)`;
      const frag = document.createDocumentFragment();
      for(let i=start;i<end;i++){
        const item = state.filteredRows[i]; if(!item) continue;
        const row = document.createElement("div");
        row.className="row-item";
        row.style.gridTemplateColumns = $thead.style.gridTemplateColumns;
        const c0 = document.createElement("div"); c0.className="cell symbol"; c0.textContent=item.s; row.appendChild(c0);
        const d = Array.isArray(item.d)? item.d : [];
        let j=0; for(const _c of state.selectedColumns){ const cell=document.createElement("div"); cell.className="cell"; cell.textContent = d[j++]; row.appendChild(cell); }
        frag.appendChild(row);
      }
      $rows.replaceChildren(frag);
    }
    $viewport.addEventListener("scroll", renderRows);
    window.addEventListener("resize", renderRows);
  
    // Export functionality
    function exportResults(format) {
      if (state.filteredRows.length === 0) {
        setStatus("No data to export.");
        return;
      }
  
      const columns = ["s", ...state.selectedColumns];
      let content = "";
      let filename = "";
  
      if (format === "csv") {
        // Create CSV header
        content += columns.join(",") + "\n";
  
        // Add data rows
        state.filteredRows.forEach(row => {
          const rowData = [row.s, ...(row.d || [])];
          content += rowData.map(item => `"${item}"`).join(",") + "\n";
        });
  
        filename = "filtered_results.csv";
      } else if (format === "json") {
        // Create JSON data
        const jsonData = state.filteredRows.map(row => {
          const rowObj = { s: row.s };
          state.selectedColumns.forEach((col, index) => {
            rowObj[col] = row.d ? row.d[index] : "";
          });
          return rowObj;
        });
  
        content = JSON.stringify(jsonData, null, 2);
        filename = "filtered_results.json";
      }
  
      // Create download link
      const blob = new Blob([content], { type: format === "csv" ? "text/csv" : "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
  
      setStatus(`Exported ${state.filteredRows.length} rows as ${format.toUpperCase()}.`);
    }
  
    // Event listener for export button
    $("exportResults").addEventListener("click", () => {
      // Show a simple dialog to choose format
      const format = prompt("Choose export format (csv/json):", "csv");
      if (format && (format.toLowerCase() === "csv" || format.toLowerCase() === "json")) {
        exportResults(format.toLowerCase());
      } else {
        setStatus("Invalid format. Please choose 'csv' or 'json'.");
      }
    });

  // TradingView fetch (simple request: no headers)
  async function fetchChunk({ market, columns, sortBy, sortOrder, start, end }){
    const body = { symbols:{ query:{ types:[] }, tickers:[] }, columns, sort:{ sortBy, sortOrder }, range:[start,end] };
    const res = await fetch(`https://scanner.tradingview.com/${market}/scan`, { method:"POST", body: JSON.stringify(body) });
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    return res.json();
  }

  async function fetchAll(){
    state.stop=false;
    const markets = [...state.selectedMarkets];
    if(markets.length===0) return setStatus("Select at least one market.");
    const columns = [...state.selectedColumns];
    if(columns.length===0) return setStatus("Select at least one column.");

    state.rows=[]; state.filteredRows=[]; state.total=0; state.loaded=0;
    renderHeader(); updateBadges(); setContainerHeight(); renderRows();

    const sortBy = $("sortBy").value.trim() || "name";
    const sortOrder = $("sortOrder").value === "desc" ? "desc" : "asc";
    const batch = Math.max(100, Math.min(5000, parseInt($("batch").value||"5000",10)));

    for(const market of markets){
      if (state.stop) break;
      setStatus(`Loading ${market}‚Ä¶`);
      let start=0, end=start+batch;
      let first;
      try{ first = await fetchChunk({ market, columns, sortBy, sortOrder, start, end }); }
      catch(e){ setStatus(`Failed ${market}: ${e.message}`); continue; }

      state.total = (state.total||0) + (first.totalCount ?? first.data.length);
      state.rows = state.rows.concat(first.data);
      state.loaded = state.rows.length; 
      filterRows(); updateBadges();

      while(!state.stop && state.rows.length < state.total){
        start = state.rows.length; end = Math.min(state.total, start + batch);
        try{
          const chunk = await fetchChunk({ market, columns, sortBy, sortOrder, start, end });
          state.rows = state.rows.concat(chunk.data);
          state.loaded = state.rows.length; 
          filterRows(); updateBadges();
          await new Promise(r=>setTimeout(r,0));
        }catch(e){ setStatus(`Stopped on error: ${e.message}`); break; }
      }
    }
    setStatus(state.stop ? "Stopped." : `Done. Loaded ${state.loaded} rows across ${markets.length} market(s).`);
  }

  // Events
  $("loadMarkets").addEventListener("click", loadMarketsFromGitHub);
  $("refreshMarkets").addEventListener("click", ()=>{ state.cache.markets=[]; state.cache.columnsByMarket={}; saveCache(); hydrateMarketsUI(); setStatus("Markets cache cleared."); });
  $("loadColumns").addEventListener("click", loadColumnsForSelected);
  $("refreshColumns").addEventListener("click", ()=>{ for(const m of state.selectedMarkets) delete state.cache.columnsByMarket[m]; saveCache(); hydrateColumnsUI(); setStatus("Columns cache cleared for selected markets."); });

  $("fetch").addEventListener("click", fetchAll);
  $("stop").addEventListener("click", ()=>{ state.stop=true; });

  // export/import cache
  $("exportCache").addEventListener("click", ()=>{
    const blob = new Blob([JSON.stringify(state.cache,null,2)], {type:"application/json"});
    const a = document.createElement("a"); a.href = URL.createObjectURL(blob); a.download = "tv_meta_cache.json"; a.click(); URL.revokeObjectURL(a.href);
  });
  $("importBtn").addEventListener("click", ()=>$("importCache").click());
  $("importCache").addEventListener("change", async (e)=>{
    const file = e.target.files?.[0]; if(!file) return;
    try{
      const txt = await file.text(); const data = JSON.parse(txt);
      if(data?.markets && data?.columnsByMarket){ state.cache = data; saveCache(); await hydrateMarketsUI(); await hydrateColumnsUI(); setStatus("Cache imported."); }
      else setStatus("Invalid JSON.");
    }catch{ setStatus("Import failed."); }
  });

  // Table search functionality
  $("tableSearch").addEventListener("input", debounce(e => {
    state.searchQuery = e.target.value;
    filterRows();
  }));
  
  $("clearSearch").addEventListener("click", () => {
    $("tableSearch").value = "";
    state.searchQuery = "";
    document.querySelectorAll('.col-filter').forEach(input => input.value = '');
    state.columnFilters = {};
    filterRows();
  });

  // Column filter functionality
  $("thead-container").addEventListener("input", debounce(e => {
    if (e.target.classList.contains("col-filter")) {
      const idx = e.target.dataset.colIdx;
      state.columnFilters[idx] = e.target.value;
      filterRows();
    }
  }, 250));

  // Boot
  loadCache();
  hydrateMarketsUI();
  renderHeader();
  updateBadges();
  setStatus("Ready. Load markets from GitHub, select markets, then load columns.");
</script>
</body>
</html>